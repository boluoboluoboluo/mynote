### 协程

```py
#协程：通过生成器（Generator）或async/await语法，将函数转换为可暂停的状态机

#挂起（Suspension）的原理
	当异步操作（如I/O、定时器）需要等待时，事件循环会挂起当前任务，释放控制权以处理其他任务。
    挂起的本质是保存当前执行状态，包括：
	#程序计数器（PC）：记录代码执行位置。
	#局部变量和堆栈状态：保存函数调用的上下文。
	#Promise/Future状态（如JavaScript/Python）：标记异步操作的完成情况。
```

#### 锁

```py
async def worker(lock, id):
    async with lock:
        print(f"Worker {id} acquired lock")
        await asyncio.sleep(1)

async def main():
    lock = asyncio.Lock()
    await asyncio.gather(*(worker(lock, i) for i in range(3))
```



#### 异步并发

1. **异步编程核心**：通过 `async/await` 定义协程，利用事件循环实现非阻塞调度。
2. **并发实现**：使用 `asyncio.gather` 或 `asyncio.create_task` 启动多个协程任务。
3. **性能优势**：适合 I/O 密集型场景（如网络请求、文件读写），显著减少总耗时。

示例：

```py
import asyncio

#定义协程
async def say(i):
	await asyncio.sleep(1)	#模拟异步任务
	#time.sleep(1)			#如果此句代替上面一句，则仍属于顺序执行，不会产生并发
	print(i)

async def main():
	tasks = [say(i) for i in range(10)]
	await asyncio.gather(*tasks)	#同时启动多个协程任务

asyncio.run(main())
print("hello")
```

- **单次调用**：`asyncio.run()` 每次调用都会创建新的事件循环，不可嵌套调用。
- **替代旧模式**：替代了旧版的 `loop.run_until_complete()` + 手动循环管理，避免资源泄漏。

#### 队列实现添加异步任务

```py
# asyncio.Queue 的阻塞行为通常由其容量（maxsize）自动控制
# 
block_event = asyncio.Event()	# 初始未阻塞
block_event.set()				# 触发阻塞
block_event.clear()				# 解除阻塞

#等待队列清空(协程会阻塞，直到所有通过 queue.put() 添加的任务都调用了 queue.task_done()。)
# await queue.join()	
queue.task_done()		#这会更新队列内部计数器，表明该任务已被处理完毕。
```

代码示例

```py
import asyncio
import time

async def job(i):
	# time.sleep(1)
	await asyncio.sleep(2)
	print(f'job [{i}] run...')

async def create(queue):
	for i in range(10):
		# await asyncio.sleep(1)
		await queue.put(job(i))
	await asyncio.sleep(1)
	await queue.put(job(11))
	await queue.put(job(12))

async def work(queue):
	while True:
		x = await queue.get()	#注意，如果队列为空，此过程会阻塞

		asyncio.create_task(x)
		queue.task_done()		#这会更新队列内部计数器，表明该任务已被处理完毕。
		
async def main():
	queue = asyncio.Queue()
	t = asyncio.create_task(create(queue))
	t2 = asyncio.create_task(work(queue))

	await t

	await asyncio.sleep(3)
	await queue.join()	#等待队列清空(协程会阻塞，直到所有通过 queue.put() 添加的任务都调用了 queue.task_done()。)

	t2.cancel()

asyncio.run(main())
```

#### 守护线程添加异步任务

1. **事件循环的线程限制**

- Python 的 `asyncio` 事件循环通常是**线程本地**的，即每个线程需要独立管理自己的事件循环。
- 在守护线程中直接调用 `asyncio.run()` 或操作事件循环时，必须确保在该线程内**显式创建并启动事件循环**，而不是依赖其他线程的事件循环。

```py
import asyncio
import threading
import time


async def job(i):
	# await asyncio.sleep(0)
	for _ in range(10):
		print(f'{i} 正在运行...')
		await asyncio.sleep(1)

async def async_task():
	asyncio.create_task(job(1))
	asyncio.create_task(job(2))
	asyncio.create_task(job(3))
	while True:
		# print("Async task running")
		# asyncio.create_task(job(1))
		await asyncio.sleep(1)

def daemon_thread():
	loop = asyncio.new_event_loop()
	asyncio.set_event_loop(loop)		#需要显示设置，（绑定事件循环到当前线程）
	loop.run_until_complete(async_task())

thread = threading.Thread(target=daemon_thread, daemon=True)
thread.start()

while True:
	time.sleep(1)
```

2. **守护线程的提前终止**

- 守护线程会在主线程退出时**立即终止**，无论其内部的异步任务是否完成。
- 如果异步任务涉及关键操作（如写入文件、网络请求），突然终止可能导致数据丢失或资源泄漏。需通过 `try...finally` 或信号处理确保安全退出。

3. **线程安全与事件循环的隔离**

- `asyncio` 的某些操作（如修改全局事件循环）是**非线程安全**的。避免跨线程共享事件循环或协程对象。
- 在子线程中必须显式调用 `asyncio.set_event_loop()` 来绑定事件循环到当前线程。

4. **替代方案：主线程运行异步**

- 如果主程序本身是基于异步的（如使用 `asyncio.run()`），可以优先用 `asyncio.Task` 替代多线程，避免线程与异步的复杂性。



#### 异步任务的递归实现

```py
import asyncio

run_flag = 1
run_tasks = []		#运行的协程任务（run方法）
async def run(depth=0):
	global run_flag
	global run_tasks
	await asyncio.sleep(0)
	depth += 1
	print(depth)
	# print(len(run_tasks))

	try:
		run_tasks.remove(asyncio.current_task())	#列表移除当前任务（此代码要放在下面的t.cancel()前面，否则报错，因为不能取消自己）
	except:
		pass

	if depth > 5:		#递归深度，（或者满足别的条件时，根据需求设计）
		run_flag = 0
		for t in run_tasks:
			t.cancel()		#满足条件，则不再递归，并且取消其他的递归任务
		return
	for _ in range(2):
		new_t = asyncio.create_task(run(depth))
		run_tasks.append(new_t)		#将递归任务统一管理，方便达到条件时取消

async def main():
	global run_flag
	asyncio.create_task(run())

	while True:
	# while run_flag:
		await asyncio.sleep(1)

asyncio.run(main())
```





