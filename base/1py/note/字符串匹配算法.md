

| 算法         | 预处理时间    | 匹配时间   | 空间          | 适用场景           |
| :----------- | :------------ | :--------- | :------------ | :----------------- |
| 朴素算法     | O(1)          | O(mn)      | O(1)          | 短文本，简单场景   |
| KMP          | O(m)          | O(n)       | O(m)          | 通用，保证线性时间 |
| Boyer-Moore  | O(m+σ)        | 平均O(n/m) | O(m+σ)        | 大字符集，实际最快 |
| Rabin-Karp   | O(m)          | 平均O(n+m) | O(1)          | 多模式、模式检测   |
| Aho-Corasick | O(总模式长度) | O(n+z)     | O(总模式长度) | 多模式匹配         |



### KMP算法

#### KMP算法是什么？

KMP算法的全称是Knuth-Morris-Pratt算法，是一种高效的字符串匹配算法，用于在一个主串（文本串）S中查找子串（模式串）P的位置。它的核心优势是：时间复杂度为 O(n + m)（n 是主串长度，m 是模式串长度），并且在匹配过程中不会回溯主串的指针，避免了暴力匹配的低效（暴力匹配最坏情况下是 O(n × m)）。

KMP的核心：next数组（也叫部分匹配表、失败函数）KMP算法的关键是一个叫 next数组（或π数组）的预处理表。

- next[i] 表示：对于模式串P[0...i] 这个前缀，当它和主串失配时，应该把模式串滑动到哪个位置继续匹配。
- 更精确地说：next[i] 是 P[0...i] 这个字符串的最长真前缀，它同时也是真后缀的长度。

例如，模式串 P = "ababac"

解释：

- P[0...2] = "aba" → 最长相等的前缀后缀是 "a"，长度1 → next[2]=1
- P[0...3] = "abab" → 最长相等的前缀后缀是 "ab"，长度2 → next[3]=2
- P[0...4] = "ababa" → 最长相等的前缀后缀是 "aba"，长度3 → next[4]=3
- P[0...5] = "ababac" → 没有更长的，失配后回到0 → next[5]=0

#### **KMP匹配过程（伪代码）**

1. 先预计算模式串P的 next 数组。
2. 初始化 i=0（主串指针），j=0（模式串指针）
3. 遍历主串：

```py
while i < len(S):
    if S[i] == P[j]:      # 匹配成功
        i += 1
        j += 1
    if j == len(P):       # 找到完整匹配
        return i - j      # 返回起始位置
    elif i < len(S) and S[i] != P[j]:  # 失配
        if j != 0:
            j = next[j-1]  # 模式串跳到next位置
        else:
            i += 1         # j已经在0，只能主串前进
```

#### 代码

```py
def compute_next(P):
    m = len(P)
    next = [0] * m
    j = 0
    for i in range(1, m):
        while j > 0 and P[i] != P[j]:
            j = next[j-1]
        if P[i] == P[j]:
            j += 1
        next[i] = j
    return next

def kmp_search(S, P):
    n, m = len(S), len(P)
    if m == 0: return 0
    next = compute_next(P)
    j = 0
    for i in range(n):
        while j > 0 and S[i] != P[j]:
            j = next[j-1]
        if S[i] == P[j]:
            j += 1
        if j == m:
            return i - m + 1  # 找到匹配位置
            j = next[j-1]     # 继续找下一个（可选）
    return -1  # 未找到
```

#### 补充

```py
# 计算模式串p的所有子串的步长,返回步长数组next
# 步长:最长相等的前缀后缀的长度,举例:假设模式串为ababac:
# 	a 	=>								next[0]=0
# 	ab 	=> 最长相等前缀后缀: 无 			 next[1]=0 		#如果是 aa 则next[1]=1 
# 	aba => 最长相等前缀后缀: a 	长度1 	next[2]=1
# 	abab =>最长相等前缀后缀: ab 	长度2	next[3]=2
# 	ababa =>最长相等前缀后缀: aba 长度3	next[4]=3
# 	ababac =>最长相等前缀后缀: 无 		 next[5]=0
def compute_next(p):
	m = len(p)
	next = [0] * m	#初始化步长数组,为模式串p长度
	j = 0 	#当前匹配的从串指针,0开始
	for i in range(1,m):	#遍历,i:主串指针,从1开始
		#j往前移1位,然后查找next[j-1]子串的最长相等前缀后缀长度,将j偏移到这个位置,然后与p[i]比较
		#如果不相等,继续上面步骤,直到相等,或者j=0为止				
		while True:
			if j == 0:
				break
			if p[i] != p[j]:	#如果不相等
				j = next[j-1]
			else:
				break
		#如果相等,意味着匹配到的前缀多了1位,即最长相等前缀后缀: j+1
		if p[i] == p[j]:		
			j += 1 		#指针向前移动1位,准备下一轮匹配
		
		next[i] = j #当子串长度为i时,最长相等前缀后缀为j
    return next
```



### Boyer-Moore算法

文本编辑器普遍使用的算法  通常比kmp算法高效

**Boyer-Moore算法的核心思想**

Boyer-Moore算法由Robert S. Boyer和J Strother Moore在1977年提出，它采用两种启发式规则来决定模式串向右滑动的距离：

1. **坏字符规则（Bad Character Rule）**：当文本中的某个字符与模式串中的字符不匹配时，我们称文本中的这个字符为坏字符。此时，如果坏字符在模式串中存在，则将模式串向右滑动，使模式串中最后一次出现的坏字符与文本中的坏字符对齐；如果坏字符不在模式串中，则将模式串向右滑动到坏字符的下一个位置。
2. **好后缀规则（Good Suffix Rule）**：当发现不匹配时，已经匹配的部分称为好后缀。此时，将模式串向右滑动，使得模式串中另一个与好后缀相同的子串（如果存在）与文本中的好后缀对齐。如果不存在这样的子串，则根据好后缀的后缀是否与模式串的前缀匹配来滑动。

**预处理阶段构建2张表:**

```py
# 1. 坏字符表（Bad Character Table）
# 记录每个字符在模式串中最后出现的位置
def build_bad_char_table(pattern):
    table = {}
    for i, char in enumerate(pattern):
        table[char] = i  # 记录最后出现的位置
    return table

# 2. 好后缀表（Good Suffix Table）
# 记录模式串后缀的匹配信息
def build_good_suffix_table(pattern):
    # 实现较复杂，用于好后缀规则
    pass
```



### Rabin-Karp算法

**用于多模式串匹配**

- **核心逻辑**：使用哈希函数，先比较哈希值，再验证
  - 滚动哈希：O(1)时间更新文本窗口的哈希值
  - 哈希冲突时需逐字符验证

### Aho-Corasick算法

- **核心逻辑**：构建有限状态自动机（Trie + 失败指针）
  - 将所有模式串构建为Trie树
  - 添加失败指针（类似KMP的next数组）
  - 扫描文本时沿自动机转移

