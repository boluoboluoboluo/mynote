## 二叉树

### **一、二叉树基础**

#### 1. 定义与结构

- **结构**：每个节点最多有2个子节点（左子节点、右子节点）

- **代码表示**（Python示例）：

  ```py
  class TreeNode:
      def __init__(self, val=0, left=None, right=None):
          self.val = val
          self.left = left
          self.right = right
  ```

#### 2. 核心术语

| 术语     | 说明                         |
| :------- | :--------------------------- |
| 根节点   | 树的顶层节点，无父节点       |
| 叶子节点 | 没有子节点的节点             |
| 深度     | 根节点到该节点的路径长度     |
| 高度     | 节点到最远叶子节点的路径长度 |
| 子树     | 节点及其所有后代组成的结构   |

------

### **二、二叉树遍历算法**

#### 1. 深度优先遍历（DFS）

- **前序遍历**：根 → 左 → 右

  ```py
  def preorder(root):
      if not root: return []
      return [root.val] + preorder(root.left) + preorder(root.right)
  ```

- **中序遍历**：左 → 根 → 右
  （二叉搜索树中序遍历结果有序）

  ```py
  def inorder(root):
      if not root: return []
      return inorder(root.left) + [root.val] + inorder(root.right)
  ```

- **后序遍历**：左 → 右 → 根

  ```py
  def postorder(root):
      if not root: return []
      return postorder(root.left) + postorder(root.right) + [root.val]
  ```

#### 2. 广度优先遍历（BFS）

- **层次遍历**：使用队列逐层处理

  ```py
  from collections import deque
  def level_order(root):
      if not root: return []
      queue = deque([root])
      res = []
      while queue:
          level = []
          for _ in range(len(queue)):
              node = queue.popleft()
              level.append(node.val)
              if node.left: queue.append(node.left)
              if node.right: queue.append(node.right)
          res.append(level)
      return res
  ```

#### 3. 迭代实现遍历（以中序为例）

```py
def inorder_iterative(root):
    stack, res = [], []
    while stack or root:
        while root:  # 深入左子树
            stack.append(root)
            root = root.left
        node = stack.pop()
        res.append(node.val)
        root = node.right  # 转向右子树
    return res
```

------

### **三、特殊二叉树类型**

| 类型            | 特点                                     | 应用场景                  |
| :-------------- | :--------------------------------------- | :------------------------ |
| 满二叉树        | 每个节点有0或2个子节点，且叶子在同一层   | 堆结构                    |
| 完全二叉树      | 除最后一层外全满，最后一层向左对齐       | 堆结构                    |
| 二叉搜索树(BST) | 左子树所有节点值 < 根 < 右子树所有节点值 | 快速查找、排序            |
| 平衡二叉树      | 左右子树高度差 ≤1（如AVL树、红黑树）     | 保证操作时间复杂度O(logn) |

------

### **四、核心算法实现**

#### 1. 二叉树深度计算

```py
def max_depth(root):
    if not root: return 0
    return 1 + max(max_depth(root.left), max_depth(root.right))
```

#### 2. 判断平衡二叉树

```py
def is_balanced(root):
    def check(node):
        if not node: return 0
        left = check(node.left)
        right = check(node.right)
        if left == -1 or right == -1 or abs(left - right) > 1:
            return -1
        return 1 + max(left, right)
    return check(root) != -1
```

#### 3. 最近公共祖先（LCA）

```py
def lowest_common_ancestor(root, p, q):
    if not root or root == p or root == q:
        return root
    left = lowest_common_ancestor(root.left, p, q)
    right = lowest_common_ancestor(root.right, p, q)
    if left and right: return root
    return left if left else right
```

------

### **五、典型问题解析**

#### 1. 验证二叉搜索树

```py
def is_valid_bst(root):
    def validate(node, low=-float('inf'), high=float('inf')):
        if not node: return True
        if not (low < node.val < high): return False
        return validate(node.left, low, node.val) and validate(node.right, node.val, high)
    return validate(root)
```

#### 2. 路径总和问题

```py
def has_path_sum(root, target):
    if not root: return False
    if not root.left and not root.right:  # 叶子节点
        return target == root.val
    return has_path_sum(root.left, target - root.val) or has_path_sum(root.right, target - root.val)
```

------

### **六、进阶应用场景**

1. **数据库索引**：B树/B+树基于平衡二叉树思想
2. **文件系统**：目录结构常用树形表示
3. **表达式解析**：构建语法树进行运算
4. **决策树算法**：机器学习中的树形分类模型



## 平衡二叉树

#### **一、平衡二叉树的核心概念**

**平衡二叉树**（Balanced Binary Tree）是一种特殊的二叉搜索树，其左右子树的高度差被严格限制（通常不超过1），从而保证树的高度近似为 **O(log n)**，确保插入、删除、查找等操作的时间复杂度稳定高效。

| 类型   | 平衡条件                  | 典型结构 |
| :----- | :------------------------ | :------- |
| AVL树  | 任意节点左右子树高度差 ≤1 | 严格平衡 |
| 红黑树 | 通过颜色规则保证近似平衡  | 宽松平衡 |

------

#### **二、平衡实现的核心操作**

平衡二叉树的核心在于**旋转调整**，当插入或删除节点导致树不平衡时，通过旋转恢复平衡。以AVL树为例，共有4种旋转情况：

##### **1. 左左失衡（LL型）**

- **失衡原因**：左子树高度 > 右子树高度 +1，且左子树的左子树更高。

- **调整方法**：**右旋**

  ```py
  def right_rotate(z):
      y = z.left
      T3 = y.right
      y.right = z
      z.left = T3
      return y  # 新的根节点
  ```

##### **2. 右右失衡（RR型）**

- **失衡原因**：右子树高度 > 左子树高度 +1，且右子树的右子树更高。

- **调整方法**：**左旋**

  ```py
  def left_rotate(z):
      y = z.right
      T2 = y.left
      y.left = z
      z.right = T2
      return y  # 新的根节点
  ```

##### **3. 左右失衡（LR型）**

- **失衡原因**：左子树的右子树更高。
- **调整方法**：先左旋左子树，再右旋根节点。

##### **4. 右左失衡（RL型）**

- **失衡原因**：右子树的左子树更高。
- **调整方法**：先右旋右子树，再左旋根节点。

------

#### **三、AVL树完整实现（Python）**

##### **1. 节点结构**

```py
class AVLNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.height = 1  # 节点高度
```

##### **2. 插入操作**

```py
def insert(root, key):
    # 1. 标准BST插入
    if not root:
        return AVLNode(key)
    elif key < root.key:
        root.left = insert(root.left, key)
    else:
        root.right = insert(root.right, key)
    
    # 2. 更新高度
    root.height = 1 + max(get_height(root.left), get_height(root.right))
    
    # 3. 计算平衡因子
    balance = get_balance(root)
    
    # 4. 根据失衡类型旋转调整
    # 左左失衡
    if balance > 1 and key < root.left.key:
        return right_rotate(root)
    # 右右失衡
    if balance < -1 and key > root.right.key:
        return left_rotate(root)
    # 左右失衡
    if balance > 1 and key > root.left.key:
        root.left = left_rotate(root.left)
        return right_rotate(root)
    # 右左失衡
    if balance < -1 and key < root.right.key:
        root.right = right_rotate(root.right)
        return left_rotate(root)
    return root
```

##### **3. 辅助函数**

```py
def get_height(node):
    if not node:
        return 0
    return node.height

def get_balance(node):
    if not node:
        return 0
    return get_height(node.left) - get_height(node.right)
```

------

#### **四、复杂度分析**

| 操作     | 时间复杂度 | 空间复杂度 |
| :------- | :--------- | :--------- |
| 插入     | O(log n)   | O(log n)   |
| 删除     | O(log n)   | O(log n)   |
| 查找     | O(log n)   | O(1)       |
| 旋转调整 | O(1)       | O(1)       |

------

#### **五、应用场景**

1. **数据库索引**：B+树基于平衡树思想，支持快速范围查询。
2. **内存高效存储**：保证数据操作的高效性，如C++的`std::map`使用红黑树。
3. **实时系统**：稳定时间复杂度适用于对响应时间敏感的场景。

------

#### **六、常见问题**

**Q1：AVL树与红黑树如何选择？**

- **AVL树**：适合读操作多、写操作少的场景（严格平衡，查询更快）。
- **红黑树**：适合写操作频繁的场景（旋转次数少，插入删除更快）。

**Q2：如何处理删除后的失衡？**
删除节点后需从被删除节点的父节点向上回溯，检查并调整每个祖先节点的平衡因子，若失衡则旋转。



## **红黑树（Red-Black Tree）详解**

------

#### **一、红黑树的核心概念**

红黑树是一种**自平衡二叉搜索树**，通过颜色标记和旋转操作，保证树的高度近似平衡，从而在插入、删除、查找等操作中保持 **O(log n)** 的时间复杂度。它是工程中应用最广泛的平衡树之一（如Java的`TreeMap`、C++的`std::map`）。

------

#### **二、红黑树的五大性质**

红黑树必须满足以下规则：

1. **颜色属性**：每个节点是红色或黑色。
2. **根节点属性**：根节点必须是黑色。
3. **叶子节点属性**：所有叶子节点（NIL节点，空节点）是黑色。
4. **红色节点规则**：红色节点的子节点必须是黑色（即不允许连续红色节点）。
5. **路径黑高相同**：从任意节点到其所有叶子节点的路径中，黑色节点的数量（黑高）必须相同。

------

#### **三、红黑树 vs AVL树**

| 特性              | 红黑树                             | AVL树                            |
| :---------------- | :--------------------------------- | :------------------------------- |
| **平衡条件**      | 宽松平衡（最长路径 ≤ 2倍最短路径） | 严格平衡（高度差 ≤1）            |
| **插入/删除效率** | 旋转次数少，操作更快               | 旋转次数多，操作稍慢             |
| **查询效率**      | 略低于AVL树（树高稍高）            | 更高（严格平衡）                 |
| **应用场景**      | 频繁插入删除的场景（如内存数据库） | 频繁查询的场景（如静态数据存储） |

------

#### **四、红黑树的插入操作**

插入新节点时默认标记为红色，可能破坏红黑树规则，需通过**旋转**和**颜色调整**修复。

##### **插入修复的三种情况**

1. **Case 1：叔叔节点是红色**
   - 将父节点和叔叔节点变黑，祖父节点变红，然后递归处理祖父节点。
2. **Case 2：叔叔节点是黑色，且新节点是父节点的右子节点**
   - 对父节点左旋，转化为Case 3。
3. **Case 3：叔叔节点是黑色，且新节点是父节点的左子节点**
   - 父节点变黑，祖父节点变红，对祖父节点右旋。

------

#### **五、红黑树的删除操作**

删除节点后可能破坏黑高或颜色规则，需分情况修复：

1. **被删节点是红色**：直接删除，不影响平衡。
2. **被删节点是黑色**：需要复杂调整。

##### **删除修复的四种情况**

1. **Case 1：兄弟节点是红色**
   - 将兄弟节点变黑，父节点变红，对父节点左旋/右旋，转化为其他情况。
2. **Case 2：兄弟节点是黑色，且兄弟的两个子节点都是黑色**
   - 将兄弟节点变红，递归处理父节点。
3. **Case 3：兄弟节点是黑色，且兄弟的左子节点红、右子节点黑**
   - 兄弟节点变红，兄弟的左子节点变黑，对兄弟右旋，转化为Case 4。
4. **Case 4：兄弟节点是黑色，且兄弟的右子节点红**
   - 兄弟节点颜色继承父节点，父节点变黑，兄弟的右子节点变黑，对父节点左旋/右旋。

------

#### **六、红黑树的代码实现（Python伪代码）**

##### **1. 节点定义**

```py
class RBNode:
    def __init__(self, key, color='RED'):
        self.key = key
        self.color = color  # 初始颜色为红色
        self.left = None    # 左子节点（默认为NIL）
        self.right = None   # 右子节点
        self.parent = None  # 父节点
```

##### **2. 左旋操作**

```py
def left_rotate(tree, x):
    y = x.right
    x.right = y.left
    if y.left != tree.nil:
        y.left.parent = x
    y.parent = x.parent
    if x.parent == tree.nil:
        tree.root = y
    elif x == x.parent.left:
        x.parent.left = y
    else:
        x.parent.right = y
    y.left = x
    x.parent = y
```

##### **3. 插入修复（核心片段）**

```py
def insert_fixup(tree, z):
    while z.parent.color == 'RED':
        if z.parent == z.parent.parent.left:
            uncle = z.parent.parent.right
            if uncle.color == 'RED':  # Case 1
                z.parent.color = 'BLACK'
                uncle.color = 'BLACK'
                z.parent.parent.color = 'RED'
                z = z.parent.parent
            else:
                if z == z.parent.right:  # Case 2
                    z = z.parent
                    left_rotate(tree, z)
                z.parent.color = 'BLACK'  # Case 3
                z.parent.parent.color = 'RED'
                right_rotate(tree, z.parent.parent)
        else:
            # 对称处理右子树的情况
    tree.root.color = 'BLACK'
```

------

#### **七、红黑树的应用场景**

1. **Java集合框架**
   - `TreeMap`、`TreeSet`基于红黑树实现有序映射和集合。
2. **Linux内核**
   - 进程调度中的`CFS`（完全公平调度器）使用红黑树管理任务队列。
3. **数据库系统**
   - MySQL的索引结构在某些场景下使用红黑树优化查询。
4. **实时计算**
   - 高频数据更新场景中保证稳定性能。

------

#### **八、常见问题解答**

**Q1：为什么红黑树比AVL树应用更广泛？**
红黑树的插入/删除操作旋转次数更少，适合写多读少的场景（如内存数据库），而AVL树的严格平衡更适合读密集操作（如文件系统索引）。

**Q2：红黑树的叶子节点为什么是NIL节点？**
为了统一处理边界条件，所有实际数据节点的子节点指向NIL节点，简化代码实现。

**Q3：如何保证红黑树的高度平衡？**
通过颜色规则和旋转操作，确保最长路径不超过最短路径的2倍（黑高相同，红色节点不连续）。



## 应用说明

### **一、基础二叉搜索树 (BST)**

#### 特点

- **结构**：左子树 < 根 < 右子树
- **优势**：简单直观，支持快速查找（平均 O(log n)）
- **缺陷**：不平衡时退化为链表（最坏 O(n)）

#### 应用场景

- 教学演示、简单数据排序
- **实际限制**：因易失衡，工业场景中很少直接使用原始BST

------

### **二、平衡二叉树**

#### 1. **AVL树**

- **平衡条件**：左右子树高度差 ≤1
- **特点**：严格平衡，查询效率极高（O(log n)）
- **应用**：
  - 早期数据库索引（如SQLite）
  - 内存受限场景的快速查找（如嵌入式系统）
- **代价**：插入/删除时频繁旋转调整

#### 2. **红黑树**（工业级首选）

- **平衡条件**：通过颜色规则保证最长路径 ≤ 2倍最短路径
- **特点**：
  - 插入/删除效率高（旋转次数少）
  - 牺牲部分平衡性换取更高写性能
- **应用**：
  - Java的`TreeMap`、C++的`std::map`
  - Linux内核进程调度（CFS公平调度器）
  - Epoll事件管理（高效维护就绪队列）

------

### **三、完全二叉树**

#### 1. **堆（Heap）**

- **结构**：完全二叉树 + 父节点值 ≥（或 ≤）子节点
- **类型**：
  - 大顶堆（根节点最大）
  - 小顶堆（根节点最小）
- **应用**：
  - 优先级队列（如Python的`heapq`模块）
  - 定时任务调度（如Kafka消息延迟队列）
  - 堆排序算法（时间复杂度 O(n log n)）

#### 2. **优先队列实现**

- **代码示例**（Python）：

  ```py
  import heapq
  data = []
  heapq.heappush(data, 5)  # 插入元素
  heapq.heappop(data)      # 弹出最小值
  ```

------

### **四、特殊用途二叉树**

#### 1. **字典树（Trie）**

- **结构**：节点存储字符，路径构成完整单词
- **特点**：前缀匹配效率极高
- **应用**：
  - 输入法词库（如搜狗拼音）
  - 路由表匹配（IP地址最长前缀匹配）
  - 敏感词过滤系统

#### 2. **B树/B+树**

- **结构**：多路平衡搜索树（非严格二叉树）
- **核心优势**：减少磁盘I/O（每个节点存储多个键值）
- **应用**：
  - 数据库索引（MySQL的InnoDB引擎用B+树）
  - 文件系统（NTFS、ReiserFS）
  - 分布式存储（如Google的Bigtable）

#### 3. **线段树（Segment Tree）**

- **结构**：二叉树存储区间信息
- **特点**：高效处理区间查询/更新
- **应用**：
  - 游戏开发中的碰撞检测
  - 实时数据统计（如股票区间最大值）
  - 地理信息系统（GIS）范围查询

------

### **五、各类型对比与选型建议**

| 类型   | 查询效率 | 插入/删除效率 | 空间复杂度 | 适用场景               |
| :----- | :------- | :------------ | :--------- | :--------------------- |
| 红黑树 | O(log n) | O(log n)      | O(n)       | 高频写入的键值存储     |
| AVL树  | O(log n) | O(log n)      | O(n)       | 读密集型场景（如缓存） |
| B+树   | O(log n) | O(log n)      | O(n)       | 磁盘存储的数据库索引   |
| 堆     | O(1)     | O(log n)      | O(n)       | 优先级调度/TOP K问题   |
| 字典树 | O(L)     | O(L)          | O(N*L)     | 前缀匹配/词频统计      |

（L：字符串长度，N：键数量）

------

### **六、工业级实现案例**

1. **Redis有序集合**：使用跳表（非二叉树）和字典组合实现，类似扩展二叉树思想
2. **Linux虚拟内存管理**：用红黑树跟踪虚拟内存区域（vm_area_struct）
3. **HTTP路由器**：Radix Tree（压缩字典树）实现高效路径匹配

------

### **总结建议**

- **需要严格查询效率** → AVL树
- **高并发写入场景** → 红黑树
- **海量磁盘数据** → B+树
- **快速极值获取** → 堆
- **字符串处理** → 字典树

实际工程中常根据场景组合使用多种树结构（如MySQL用B+树做主索引，内存用红黑树做缓存）。