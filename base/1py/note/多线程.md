### 说明

```py
# python的多线程机制因为GIL（全局解释器锁）的作用，导致多线程无法并行执行

# GIL是一把全局锁，同一时刻只允许一个线程执行Python字节码。即使有多个线程，CPython解释器也会强制它们轮流运行（单核并发，而非多核并行）。

# 即使在多核CPU上，Python的多线程也无法实现真正的并行执行。
# 不过对于I/O密集型任务，多线程还是有用的，因为线程在等待I/O时 可以释放GIL，让其他线程运行。
```

```py
import threading

# 获取当前线程对象
current_thread = threading.current_thread()

# 打印线程信息
print("当前线程名称:", current_thread.name)
print("当前线程ID:", current_thread.ident)
print("当前线程对象:", current_thread)
```

```py
import threading
import time

def task():
    print("子线程名称:", threading.current_thread().name)
    time.sleep(1)

# 创建并启动子线程
thread = threading.Thread(target=task, name="MyThread")
thread.start()
thread.join()

# 主线程继续执行
print("主线程名称:", threading.current_thread().name)
```



### 使用

#### 方式一

```py
# -*- coding:utf-8 -*-
# 线程使用的方式一
import threading
import time


# 需要多线程运行的函数
def fun(args):
    print("我是线程%s" % args)
    time.sleep(2)
    print("线程%s运行结束" % args)


# 创建线程
t1 = threading.Thread(target=fun, args=(1,))
t2 = threading.Thread(target=fun, args=(2,))
start_time = time.time()
t1.start()
t2.start()
end_time = time.time()
print("两个线程一共的运行时间为：", end_time-start_time)
print("主线程结束")
```

#### 方式二：继承调用

```py
# 继承式调用
import threading
import time


class MyThreading(threading.Thread):
    def __init__(self, name):
        super(MyThreading, self).__init__()
        self.name = name

    # 线程要运行的代码
    def run(self):
        print("我是线程%s" % self.name)
        time.sleep(2)
        print("线程%s运行结束" % self.name)


t1 = MyThreading(1)
t2 = MyThreading(2)
start_time = time.time()
t1.start()
t2.start()
end_time = time.time()
print("两个线程一共的运行时间为：", end_time-start_time)
print("主线程结束")
```

### 守护线程

实现主程序结束，子程序立马全部结束功能

```py
# 守护线程
import threading
import time


class MyThreading(threading.Thread):
    def __init__(self, name):
        super(MyThreading, self).__init__()
        self.name = name

    # 线程要运行的代码
    def run(self):
        print("我是线程%s" % self.name)
        time.sleep(2)
        print("线程%s运行结束" % self.name)


t1 = MyThreading(1)
t2 = MyThreading(2)
start_time = time.time()
t1.setDaemon(True)
t1.start()
t2.setDaemon(True)
t2.start()
end_time = time.time()
print("两个线程一共的运行时间为：", end_time-start_time)
print("主线程结束")
```

### join

主程序将一直等待子程序全部运行完成才结束

```py
# join:线程同步
import threading
import time


class MyThreading(threading.Thread):
    def __init__(self, name):
        super(MyThreading, self).__init__()
        self.name = name

    # 线程要运行的代码
    def run(self):
        print("我是线程%s" % self.name)
        time.sleep(3)
        print("线程%s运行结束" % self.name)


threading_list = []
start_time = time.time()
for x in range(50):
    t = MyThreading(x)
    t.start()
    threading_list.append(t)

for x in threading_list:
    x.join()    # 为线程开启同步

end_time = time.time()
print("50个线程一共的运行时间为：", end_time-start_time)
print("主线程结束")
```

### 锁

```py
import threading

#transaction_lock = threading.Lock()		#不可重入锁，递归或同一线程多次调用会导致无法获取锁
transaction_lock = threading.RLock()	#可重入锁

with transaction_lock:
    print("hello")

```

### 结束

```py
import threading
import sys

def my_thread():
    print("Thread starting")
    sys.exit()  # 结束当前线程
    print("This will not print")

thread = threading.Thread(target=my_thread)
thread.start()
thread.join()
print("Main thread continues")
```

