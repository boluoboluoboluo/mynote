### **1. `get_peers` 的作用**

在 BitTorrent 的 DHT 网络中，`get_peers` 是核心操作之一，用于**根据资源的 InfoHash（如种子文件的哈希）查询正在下载/上传该资源的 Peer 列表**。

- 当客户端需要下载某个资源时，会通过 `get_peers` 请求从 DHT 网络中找到持有该资源的 Peer。
- 该操作基于 Kademlia 协议实现，但针对 BitTorrent 场景进行了扩展（参考 [BEP 5](http://bittorrent.org/beps/bep_0005.html)）。

------

### **2. `get_peers` 的流程**

#### **步骤 1：初始化查询**

- 客户端生成目标资源的 **InfoHash**（例如从 Magnet 链接中提取的 `btih` 值）。
- 在本地 DHT 路由表中查找距离该 InfoHash **最近** 的已知节点（基于 XOR 距离）。

#### **步骤 2：发送 `get_peers` 请求**

向选中的节点发送 `get_peers` 请求，消息格式如下（基于 **Bencode** 编码）：

```py
{
  "t": "<事务ID>",        # 唯一标识本次请求的随机字符串（如 "aa"）
  "y": "q",              # 表示这是一个查询请求
  "q": "get_peers",      # 操作类型
  "a": {
    "id": "<节点ID>",     # 发起请求的节点 ID（160 位）
    "info_hash": "<目标资源的 InfoHash>"  # 20 字节的哈希值
  }
}
```

#### **步骤 3：处理响应**

被查询的节点可能返回两种类型的响应：

1. **返回 Peer 列表**
   如果该节点或其路由表中的节点存储了目标 InfoHash 对应的 Peer，直接返回 Peer 信息：

   ```py
   {
     "t": "<事务ID>",
     "y": "r",            # 表示这是一个响应
     "r": {
       "id": "<响应节点ID>",
       "token": "<令牌>",  # 用于后续的 `announce_peer` 操作
       "values": [         # Peer 列表（IPv4 或 IPv6 地址）
         "<IP:端口>",      # 例如 "1.2.3.4:6881"
         ...
       ]
     }
   }
   ```

2. **返回更接近的节点列表**
   如果当前节点没有目标 Peer 信息，返回距离 InfoHash 更近的节点列表（供客户端递归查询）：

   ```py
   {
     "t": "<事务ID>",
     "y": "r",
     "r": {
       "id": "<响应节点ID>",
       "nodes": "<紧凑格式的节点列表>",  # 格式为：<节点ID(20字节)><IP(4字节)><端口(2字节)>...
       "token": "<令牌>"
     }
   }
   ```

#### **步骤 4：递归查询**

- 客户端从响应中提取更接近的节点，重复步骤 2~3，直到找到足够数量的 Peer 或达到查询深度限制。

#### **步骤 5：超时与重试**

- 若节点未响应，客户端会标记该节点为“不可达”并尝试其他节点。
- 默认超时时间通常为 **15 秒**。

------

### **3. 关键实现细节**

#### **Peer 存储规则**

- DHT 节点会将 Peer 信息存储在 **距离 InfoHash 最近的 k 个节点** 上（默认 `k=8`）。
- Peer 信息会定期刷新（通常每 **30 分钟** 重新发布一次）。

#### **令牌（Token）机制**

- 在 `get_peers` 响应中，节点返回的 `token` 是一个短期有效的凭证。
- 客户端需使用此 `token` 在后续的 `announce_peer` 操作中证明自己参与了查询（防止伪造攻击）。

#### **Compact 格式编码**

- **Peer 地址**（`values` 字段）使用紧凑格式：
  - IPv4：6 字节（4 字节 IP + 2 字节端口，大端序）。
  - IPv6：18 字节（16 字节 IP + 2 字节端口）。
- **节点列表**（`nodes` 字段）使用紧凑格式：26 字节/节点（20 字节节点 ID + 4 字节 IP + 2 字节端口）。

------

### **4. 示例场景**

假设客户端要下载 InfoHash 为 `H` 的资源：

1. 客户端向节点 `A` 发送 `get_peers` 请求。
2. 节点 `A` 没有 `H` 的 Peer 信息，返回距离 `H` 更近的节点列表 `B, C, D`。
3. 客户端向节点 `B` 发送 `get_peers` 请求。
4. 节点 `B` 存储了 `H` 的 Peer 信息，返回 `values: ["192.168.1.1:6881", "10.0.0.2:6999"]`。
5. 客户端连接这些 Peer 开始下载。

------

### **5. 常见问题与优化**

#### **Q: 如何避免恶意节点返回虚假 Peer？**

- **令牌验证**：只有通过合法 `get_peers` 请求获得的 `token` 才能用于 `announce_peer`。
- **交叉验证**：客户端从多个节点获取 Peer 列表，过滤不一致的结果。

#### **Q: 如何处理 NAT 穿透？**

- 若 Peer 位于 NAT 后，需依赖 **UPnP** 或 **NAT-PMP** 自动端口映射。
- 部分客户端使用 **反向连接**（通过 Tracker 或 DHT 协调）。

#### **Q: 如何提高查询效率？**

- **并行查询**：同时向多个节点发送 `get_peers` 请求（参数 `α=3` 控制并发数）。
- **缓存结果**：在本地缓存常用的 Peer 列表，减少重复查询。

------

### **6. 相关 BEP 扩展**

- **BEP 5**：DHT 协议基础定义。
- **BEP 44**：允许在 DHT 中存储小型可变数据（扩展了 `get_peers` 的用途）。
- **BEP 51**：支持 IPv6 的 DHT 扩展。

------

### **7. 调试工具与代码参考**

- **Wireshark 过滤规则**：
  `dht && bittorrent.dht.message_type == 1`（`get_peers` 请求）。
