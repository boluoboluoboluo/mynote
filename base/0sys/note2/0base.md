

#### 关于大端小端

```sh
#在当前类型大小的内部
大端:以字节为单位,正序存放
小端:以字节为单位,倒序存放
#比如int(4个字节)数字:0x12345678	#16进制表示
大端存放:12345678
小端存放:78563412

#大部分系统使用小端,为了历史兼容
#历史早期优势: 小端可以从开始读低字节,边读边计算,大端只能全部读完再计算

```

#### 进制转换思路

```sh
#示例:10进制转2进制
#假设数字num=101
步骤a. num%2=d1 #得到最低位的进制d1	# 这个应该不难理解
步骤b. 先num/2=num2,再执行:num2%2=d2 #d2与d1合并,此时得出最低位的2个进制=>d2d1	
重复执行步骤b. 得出的结果放在之前合并的进制前面

#原理:
第1步通过模运算得出最低位进制,应该容易理解
第2步,为什么要先除2呢,拆解如下:(假设数字为101对应101个苹果)
	a.求最低位进制时,最小单位是1,数字101分成101份,按2进制就是,每2份划到一起,最后只有1个苹果剩余,(101%2=1)
	剩余那个不管了,还剩100个苹果
	b.求倒数第2位进制时,此时最小单位是2, (进制每前面1位,最小单位都是后面1位的进制倍数)
	此时得把每2个苹果绑定在一起(这里用黑色袋子装起来)当作最小单位,结果就是50份,
	然后这50份求低位进制,2份放一起,剩余0份,(50%2=0)
	c.继续求倒数第3位进制,此时最小单位是4(2^2),即50份再每2份放一起(用黑色袋子装起来),结果是25份,
	然后这25份求低位进制,2份放一起,剩余1份,(25%2=1)
	...
	重复,每进一位就x2当作最小单位(用新袋子把之前的2个袋子装进来)
	
#原理2:
	求哪一位的进制,比如i位,就是(101/(2^(i-1)))%2
	即2^(i-1)为最小单位
	
```

#### https长连接

```sh
#在 HTTP/1.1 中，长连接是默认开启的
客户端在请求头中携带 Connection: keep-alive
其核心目标是避免频繁进行高昂成本的 TCP 三次握手和 TLS 安全握手

#心跳探测
#当连接长时间没有数据往来时，操作系统内核会发送微小的探测报文（Keepalive Probe）给对方
1.许多 Linux 服务器的默认 tcp_keepalive_time 依然是 2 小时。这意味着如果你只发呆 10 分钟，可能还没触发系统级的探针
2.为了提高效率，很多网站服务器（如 Nginx）会把应用层的 Keep-alive 超时设为 60~120 秒。这时候，如果你一两分钟没操作，服务器可能直接根据应用层规则断开连接，而不是等待底层的 TCP 探针去探测
```

